diff --git a/ROMFS/CMakeLists.txt b/ROMFS/CMakeLists.txt
index 9b282339fd..d25f24a3df 100644
--- a/ROMFS/CMakeLists.txt
+++ b/ROMFS/CMakeLists.txt
@@ -224,6 +224,22 @@ foreach(board_rc_file ${OPTIONAL_BOARD_RC})
 
 endforeach()
 
+if(EXISTS "${PX4_BOARD_DIR}/src/etc")
+	add_custom_command(
+		OUTPUT
+			board_src_etc.stamp
+		COMMAND ${CMAKE_COMMAND} -E copy_directory ${PX4_BOARD_DIR}/src/etc ${romfs_gen_root_dir}
+		COMMAND ${CMAKE_COMMAND} -E touch board_src_etc.stamp
+		DEPENDS
+			romfs_copy.stamp
+		COMMENT "ROMFS: overlaying ${PX4_BOARD_DIR}/src/etc"
+	)
+
+	list(APPEND extras_dependencies
+		board_src_etc.stamp
+	)
+endif()
+
 if(config_additional_init)
 	if(EXISTS "${PX4_BOARD_DIR}/init/${config_additional_init}")
 		file(RELATIVE_PATH rc_file_relative ${PX4_SOURCE_DIR} ${PX4_BOARD_DIR}/init/${config_additional_init})
diff --git a/ROMFS/px4fmu_common/init.d/rcS b/ROMFS/px4fmu_common/init.d/rcS
index 1337a777c8..5859706d9f 100644
--- a/ROMFS/px4fmu_common/init.d/rcS
+++ b/ROMFS/px4fmu_common/init.d/rcS
@@ -277,8 +277,8 @@ else
 	else
 		if param compare SYS_DM_BACKEND 0
 		then
-			# dataman start default
-			dataman start
+			# dataman start default (with optional board-specific path)
+			dataman start $DATAMAN_OPT
 		fi
 	fi
 
diff --git a/boards/microchip/samv71-xult-clickboards/default.px4board b/boards/microchip/samv71-xult-clickboards/default.px4board
index b53b070d16..0be69ad6ff 100644
--- a/boards/microchip/samv71-xult-clickboards/default.px4board
+++ b/boards/microchip/samv71-xult-clickboards/default.px4board
@@ -65,6 +65,8 @@ CONFIG_MODULES_SENSORS=y
 
 # System Commands
 CONFIG_SYSTEMCMDS_BSONDUMP=y
+CONFIG_SYSTEMCMDS_LITTLEFS_MOUNT=y
+CONFIG_SYSTEMCMDS_MFT=y
 # CONFIG_SYSTEMCMDS_DMESG is not set  # Hangs due to console buffer bug - not HRT related
 # CONFIG_SYSTEMCMDS_HARDFAULT_LOG is not set  # Needs dump_s type - not implemented for SAMV7 yet
 CONFIG_SYSTEMCMDS_PARAM=y
diff --git a/boards/microchip/samv71-xult-clickboards/init/rc.board_defaults b/boards/microchip/samv71-xult-clickboards/init/rc.board_defaults
index 40cc943eec..c18310cee4 100644
--- a/boards/microchip/samv71-xult-clickboards/init/rc.board_defaults
+++ b/boards/microchip/samv71-xult-clickboards/init/rc.board_defaults
@@ -1,23 +1,12 @@
 #!/bin/sh
 #
 # SAMV71-XULT board defaults
-#------------------------------------------------------------------------------
 
-# System parameters
-param set-default SYS_AUTOSTART 4001
+# Mount LittleFS, format on first boot
+littlefs_mount -d /dev/mtdblock0 -m /fs/mtd_params || littlefs_mount -d /dev/mtdblock0 -m /fs/mtd_params -f
 
-# Enable all sensors
-param set-default SENS_EN_INA226 0
-param set-default SENS_EN_INA228 0
-param set-default SENS_EN_INA238 0
+# Override dataman storage path to use internal flash instead of SD
+set DATAMAN_OPT "-f /fs/mtd_params/dataman"
 
-# Battery monitoring (if ADC available)
-# param set-default BAT1_V_DIV 11.0
-# param set-default BAT1_A_PER_V 18.0
-
-# EKF2 Parameters
-param set-default EKF2_IMU_CTRL 7
-param set-default EKF2_MAG_TYPE 1
-
-# Logger buffer
-set LOGGER_BUF 64
+# Default airframe
+param set-default SYS_AUTOSTART 60100
diff --git a/boards/microchip/samv71-xult-clickboards/nuttx-config/nsh/defconfig b/boards/microchip/samv71-xult-clickboards/nuttx-config/nsh/defconfig
index ebdf588b27..dc5c61d7d0 100644
--- a/boards/microchip/samv71-xult-clickboards/nuttx-config/nsh/defconfig
+++ b/boards/microchip/samv71-xult-clickboards/nuttx-config/nsh/defconfig
@@ -106,6 +106,15 @@ CONFIG_MEMSET_OPTSPEED=y
 CONFIG_MM_REGIONS=2
 CONFIG_MTD=y
 CONFIG_MTD_BYTE_WRITE=y
+CONFIG_MTD_PARTITION=y
+CONFIG_MTD_PROGMEM=y
+CONFIG_FS_LITTLEFS=y
+CONFIG_FS_LITTLEFS_BLOCK_CYCLE=500
+CONFIG_FS_LITTLEFS_CACHE_SIZE_FACTOR=1
+CONFIG_FS_LITTLEFS_LOOKAHEAD_SIZE=128
+CONFIG_FS_LITTLEFS_PROGRAM_SIZE_FACTOR=1
+CONFIG_FS_LITTLEFS_READ_SIZE_FACTOR=1
+CONFIG_FS_LITTLEFS_BLOCK_SIZE_FACTOR=2
 CONFIG_NAME_MAX=40
 CONFIG_NSH_ARCHINIT=y
 CONFIG_NSH_ARGCAT=y
@@ -137,6 +146,7 @@ CONFIG_SAMV7_GPIOB_IRQ=y
 CONFIG_SAMV7_GPIOD_IRQ=y
 CONFIG_SAMV7_GPIO_IRQ=y
 CONFIG_SAMV7_PROGMEM=y
+CONFIG_SAMV7_PROGMEM_NSECTORS=2
 CONFIG_SAMV7_PWR=y
 CONFIG_SAMV7_TC0=y
 CONFIG_SAMV7_TWIHS0=y
diff --git a/boards/microchip/samv71-xult-clickboards/src/board_config.h b/boards/microchip/samv71-xult-clickboards/src/board_config.h
index 6baa48e610..d11b6ea572 100644
--- a/boards/microchip/samv71-xult-clickboards/src/board_config.h
+++ b/boards/microchip/samv71-xult-clickboards/src/board_config.h
@@ -71,6 +71,9 @@
 #define BOARD_HAS_CONTROL_STATUS_LEDS      1
 #define BOARD_ARMED_STATE_LED  LED_BLUE
 
+#define GPIO_SPI0_CS_ICM20689    (GPIO_OUTPUT|GPIO_OUTPUT_SET|GPIO_PORT_PIOA|GPIO_PIN11)
+#define GPIO_SPI0_DRDY_ICM20689  (GPIO_INPUT|GPIO_CFG_PULLUP|GPIO_PORT_PIOA|GPIO_PIN12)
+
 #define  FLASH_BASED_PARAMS
 
 /* ADC Channels ***********************************************************************************/
@@ -123,6 +126,8 @@
 
 #define PX4_GPIO_INIT_LIST { \
 		GPIO_nLED_BLUE,           \
+		GPIO_SPI0_CS_ICM20689,    \
+		GPIO_SPI0_DRDY_ICM20689,  \
 	}
 
 #define BOARD_ENABLE_CONSOLE_BUFFER
diff --git a/boards/microchip/samv71-xult-clickboards/src/init.c b/boards/microchip/samv71-xult-clickboards/src/init.c
index 151d4da1f4..a7c0d358c0 100644
--- a/boards/microchip/samv71-xult-clickboards/src/init.c
+++ b/boards/microchip/samv71-xult-clickboards/src/init.c
@@ -53,6 +53,10 @@
 #include <unistd.h>
 
 #include <nuttx/config.h>
+#if defined(CONFIG_MTD_PROGMEM)
+#  include <nuttx/mtd/mtd.h>
+#  include <nuttx/drivers/drivers.h>
+#endif
 #include <nuttx/board.h>
 #include <nuttx/mmcsd.h>
 #include <nuttx/mm/gran.h>
@@ -81,6 +85,9 @@ __BEGIN_DECLS
 extern void led_init(void);
 extern void led_on(int led);
 extern void led_off(int led);
+#if defined(CONFIG_MTD_PROGMEM)
+void sam_progmem_initialize(void);
+#endif
 __END_DECLS
 
 /************************************************************************************
@@ -111,6 +118,74 @@ __EXPORT void board_on_reset(int status)
 	(void)status;  /* Unused */
 }
 
+#if defined(CONFIG_MTD_PROGMEM)
+#define PARAM_FLASHFS_PARTITION_SIZE   (32 * 1024)
+
+static int samv71_setup_param_mtd(void)
+{
+	sam_progmem_initialize();
+
+	struct mtd_dev_s *progmem = progmem_initialize();
+
+	if (progmem == NULL) {
+		syslog(LOG_ERR, "[mtd] progmem_initialize failed\n");
+		return -ENODEV;
+	}
+
+	struct mtd_geometry_s geo;
+	int ret = progmem->ioctl(progmem, MTDIOC_GEOMETRY, (unsigned long)(uintptr_t)&geo);
+
+	if (ret < 0) {
+		syslog(LOG_ERR, "[mtd] geometry ioctl failed: %d\n", ret);
+		return ret;
+	}
+
+	const size_t progmem_size = (size_t)geo.erasesize * geo.neraseblocks;
+
+	if (PARAM_FLASHFS_PARTITION_SIZE > progmem_size) {
+		syslog(LOG_ERR, "[mtd] partition size too large (%u > %u)\n",
+		       (unsigned)PARAM_FLASHFS_PARTITION_SIZE, (unsigned)progmem_size);
+		return -EINVAL;
+	}
+
+	const size_t partition_offset = progmem_size - PARAM_FLASHFS_PARTITION_SIZE;
+
+	const off_t firstblock = partition_offset / geo.blocksize;
+	const off_t nblocks = PARAM_FLASHFS_PARTITION_SIZE / geo.blocksize;
+
+	if ((partition_offset % geo.blocksize) != 0 || (PARAM_FLASHFS_PARTITION_SIZE % geo.blocksize) != 0) {
+		syslog(LOG_ERR, "[mtd] partition not aligned to blocksize=%u\n", (unsigned)geo.blocksize);
+		return -EINVAL;
+	}
+
+	struct mtd_dev_s *param_mtd = mtd_partition(progmem, firstblock, nblocks);
+
+	if (param_mtd == NULL) {
+		syslog(LOG_ERR, "[mtd] failed to create partition (first=%ld blocks=%ld)\n",
+		       (long)firstblock, (long)nblocks);
+		return -ENOMEM;
+	}
+
+	ret = ftl_initialize(0, param_mtd);
+
+	if (ret < 0) {
+		syslog(LOG_ERR, "[mtd] ftl_initialize failed: %d\n", ret);
+		return ret;
+	}
+
+	ret = bchdev_register("/dev/mtdblock0", "/dev/mtdparams", false);
+
+	if (ret < 0) {
+		syslog(LOG_ERR, "[mtd] bchdev_register failed: %d\n", ret);
+		return ret;
+	}
+
+	syslog(LOG_INFO, "[mtd] /dev/mtdparams ready (offset=0x%zx size=%u blocks=%ld)\n",
+	       partition_offset, (unsigned)PARAM_FLASHFS_PARTITION_SIZE, (long)nblocks);
+	return OK;
+}
+#endif
+
 /************************************************************************************
  * Name: sam_boardinitialize
  *
@@ -178,6 +253,13 @@ __EXPORT int board_app_initialize(uintptr_t arg)
 	px4_platform_init();
 	syslog(LOG_ERR, "[boot] px4_platform_init completed\n");
 
+#if defined(CONFIG_MTD_PROGMEM)
+	syslog(LOG_ERR, "[boot] Setting up /dev/mtdparams from PROGMEM...\n");
+	if (samv71_setup_param_mtd() < 0) {
+		syslog(LOG_ERR, "[boot] Failed to initialize PROGMEM MTD partition\n");
+	}
+#endif
+
 	/* Initialize I2C buses - must be after px4_platform_init */
 #ifdef CONFIG_SAMV7_TWIHS0
 	syslog(LOG_ERR, "[boot] Initializing I2C bus 0 (TWIHS0)...\n");
@@ -221,9 +303,9 @@ __EXPORT int board_app_initialize(uintptr_t arg)
 	}
 
 #if defined(FLASH_BASED_PARAMS)
-	static sector_descriptor_t params_sector_map[] = {
-		{1, 128 * 1024, 0x00420000},
-		{2, 128 * 1024, 0x00440000},
+static sector_descriptor_t params_sector_map[] = {
+		{1, 128 * 1024, 0x001C0000},
+		{2, (128 * 1024) - (32 * 1024), 0x001E0000},
 		{0, 0, 0},
 	};
 
diff --git a/boards/microchip/samv71-xult-clickboards/src/spi.cpp b/boards/microchip/samv71-xult-clickboards/src/spi.cpp
index 92c5492d86..cd39e89715 100644
--- a/boards/microchip/samv71-xult-clickboards/src/spi.cpp
+++ b/boards/microchip/samv71-xult-clickboards/src/spi.cpp
@@ -31,60 +31,81 @@
  *
  ****************************************************************************/
 
+#include <board_config.h>
+#include <px4_arch/micro_hal.h>
 #include <px4_arch/spi_hw_description.h>
+#include <px4_platform_common/spi.h>
 #include <drivers/drv_sensor.h>
 #include <nuttx/spi/spi.h>
 
-/* SPI bus configuration for SAMV71-XULT with Click sensor boards
- *
- * NOTE: Pin assignments are placeholders. The actual SPI pin assignments depend on:
- * 1. Which mikroBUS socket the sensors are plugged into
- * 2. The SAMV71-XULT schematic showing SPI routing to mikroBUS sockets
- *
- * This needs to be updated once the hardware is available and schematics are reviewed.
- *
- * SAMV71-XULT has:
- * - SPI0: Typically on PA25-PA28 (MISO, MOSI, SPCK, NPCS0-3)
- * - SPI1: Typically on PC26-PC29 (MISO, MOSI, SPCK, NPCS0-3)
- *
- * For Click boards sensor connections, we'll likely use SPI0.
- */
+static constexpr px4_spi_bus_device_t make_spidev(uint32_t drvtype, uint32_t cs_gpio,
+		spi_drdy_gpio_t drdy_gpio = 0)
+{
+	return px4_spi_bus_device_t {
+		.cs_gpio = cs_gpio,
+		.drdy_gpio = drdy_gpio,
+		.devid = PX4_SPIDEV_ID(PX4_SPI_DEVICE_ID, drvtype),
+		.devtype_driver = static_cast<uint16_t>(drvtype),
+	};
+}
 
-/* Temporarily empty SPI configuration - sensors not yet wired */
 constexpr px4_spi_bus_t px4_spi_buses[SPI_BUS_MAX_BUS_ITEMS] = {
+	{
+		.devices = {
+			make_spidev(DRV_IMU_DEVTYPE_ICM20689, GPIO_SPI0_CS_ICM20689, GPIO_SPI0_DRDY_ICM20689),
+		},
+		.power_enable_gpio = 0,
+		.bus = static_cast<int8_t>(SPI::Bus::SPI0),
+		.is_external = false,
+		.requires_locking = false,
+	},
 };
 
 /* SPI chip select and status functions required by NuttX SAMV7 */
 extern "C" {
 
+static void sam_spixselect(SPI::Bus bus_id, uint32_t devid, bool selected)
+{
+	for (const auto &bus : px4_spi_buses) {
+		if (bus.bus != static_cast<int8_t>(bus_id)) {
+			continue;
+		}
+
+		for (const auto &device : bus.devices) {
+			if (device.cs_gpio == 0) {
+				continue;
+			}
+
+			const bool device_selected = (device.devid == devid) ? selected : false;
+			px4_arch_gpiowrite(device.cs_gpio, !device_selected);
+		}
+	}
+}
+
 void sam_spi0select(uint32_t devid, bool selected)
 {
-	/* No SPI devices configured yet - stub */
-	(void)devid;
-	(void)selected;
+	sam_spixselect(SPI::Bus::SPI0, devid, selected);
 }
 
 uint8_t sam_spi0status(struct spi_dev_s *dev, uint32_t devid)
 {
-	/* No SPI devices configured yet - stub */
 	(void)dev;
 	(void)devid;
-	return 0;
+	return SPI_STATUS_PRESENT;
 }
 
 void sam_spi1select(uint32_t devid, bool selected)
 {
-	/* No SPI devices configured yet - stub */
+	/* SPI1 unconnected */
 	(void)devid;
 	(void)selected;
 }
 
 uint8_t sam_spi1status(struct spi_dev_s *dev, uint32_t devid)
 {
-	/* No SPI devices configured yet - stub */
 	(void)dev;
 	(void)devid;
-	return 0;
+	return SPI_STATUS_PRESENT;
 }
 
 } // extern "C"
diff --git a/platforms/nuttx/NuttX/nuttx b/platforms/nuttx/NuttX/nuttx
--- a/platforms/nuttx/NuttX/nuttx
+++ b/platforms/nuttx/NuttX/nuttx
@@ -1 +1 @@
-Subproject commit fb2fadf6f599c1406f052db013efd00a2518e72c
+Subproject commit fb2fadf6f599c1406f052db013efd00a2518e72c-dirty
diff --git a/platforms/nuttx/src/px4/common/board_dma_alloc.c b/platforms/nuttx/src/px4/common/board_dma_alloc.c
index 6316081b49..e78517d935 100644
--- a/platforms/nuttx/src/px4/common/board_dma_alloc.c
+++ b/platforms/nuttx/src/px4/common/board_dma_alloc.c
@@ -74,6 +74,14 @@ static uint8_t g_dma_heap[BOARD_DMA_ALLOC_POOL_SIZE] __attribute__((aligned(64))
 static perf_counter_t g_dma_perf;
 static uint16_t dma_heap_inuse;
 static uint16_t dma_heap_peak_use;
+static uint32_t dma_guard;
+
+#define DMA_GUARD_MAGIC 0x444d4130u
+
+static inline bool board_dma_ready(void)
+{
+	return dma_allocator != NULL && dma_guard == DMA_GUARD_MAGIC;
+}
 
 /****************************************************************************
  * Public Functions
@@ -81,6 +89,10 @@ static uint16_t dma_heap_peak_use;
 __EXPORT int
 board_dma_alloc_init(void)
 {
+	if (board_dma_ready()) {
+		return OK;
+	}
+
 	dma_allocator = gran_initialize(g_dma_heap,
 					sizeof(g_dma_heap),
 					7,  /* 128B granule - must be > alignment (XXX bug?) */
@@ -93,6 +105,7 @@ board_dma_alloc_init(void)
 		dma_heap_inuse = 0;
 		dma_heap_peak_use = 0;
 		g_dma_perf = perf_alloc(PC_COUNT, "dma_alloc");
+		dma_guard = DMA_GUARD_MAGIC;
 	}
 
 	return OK;
@@ -111,6 +124,12 @@ board_get_dma_usage(uint16_t *dma_total, uint16_t *dma_used, uint16_t *dma_peak_
 __EXPORT void *
 board_dma_alloc(size_t size)
 {
+	if (!board_dma_ready()) {
+		if (board_dma_alloc_init() < 0) {
+			return NULL;
+		}
+	}
+
 	void *rv = NULL;
 	perf_count(g_dma_perf);
 	rv = gran_alloc(dma_allocator, size);
@@ -129,6 +148,10 @@ board_dma_alloc(size_t size)
 __EXPORT void
 board_dma_free(FAR void *memory, size_t size)
 {
+	if (!board_dma_ready()) {
+		return;
+	}
+
 	gran_free(dma_allocator, memory, size);
 	dma_heap_inuse -= size;
 }
diff --git a/platforms/nuttx/src/px4/microchip/samv7/hrt/hrt.c b/platforms/nuttx/src/px4/microchip/samv7/hrt/hrt.c
index f193ce99d5..3321a26a05 100644
--- a/platforms/nuttx/src/px4/microchip/samv7/hrt/hrt.c
+++ b/platforms/nuttx/src/px4/microchip/samv7/hrt/hrt.c
@@ -1,6 +1,6 @@
 /****************************************************************************
  *
- *   Copyright (c) 2024 PX4 Development Team. All rights reserved.
+ *   Copyright (c) 2016-2020 PX4 Development Team. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -31,12 +31,6 @@
  *
  ****************************************************************************/
 
-/**
- * @file hrt.c
- *
- * High-resolution timer for SAMV7 using TC0 (Timer/Counter 0)
- */
-
 #include <px4_platform_common/px4_config.h>
 #include <nuttx/arch.h>
 #include <nuttx/irq.h>
@@ -50,6 +44,7 @@
 #include <queue.h>
 #include <errno.h>
 #include <string.h>
+
 #include <syslog.h>
 
 #include <board_config.h>
@@ -59,6 +54,7 @@
 #include "hardware/sam_pmc.h"
 #include "hardware/sam_tc.h"
 
+
 #ifdef CONFIG_DEBUG_HRT
 #  define hrtinfo _info
 #else
@@ -66,317 +62,525 @@
 #endif
 
 #ifdef HRT_TIMER
-
-/* HRT configuration for SAMV7 TC0 */
 #if HRT_TIMER == 0
-# define HRT_TIMER_BASE		SAM_TC012_BASE
-# define HRT_TIMER_CHANNEL	0
-# define HRT_TIMER_VECTOR	SAM_IRQ_TC0
-# define HRT_TIMER_CLOCK	BOARD_MCK_FREQUENCY
-# define HRT_TIMER_PCER	(1 << SAM_PID_TC0)
+#  define HRT_TIMER_BASE      SAM_TC012_BASE
+#  define HRT_TIMER_VECTOR    SAM_IRQ_TC0
+#  define HRT_TIMER_CLOCK     BOARD_MCK_FREQUENCY
+#  define HRT_TIMER_PCER      (1 << SAM_PID_TC0)
 #else
-# error HRT_TIMER must be 0 for SAMV7 (TC0 Channel 0)
+#  error HRT_TIMER must be 0 for SAMV71 TC0
 #endif
 
-/* Minimum/maximum deadlines */
+#define HRT_TIMER_DIVISOR     32
+#define HRT_TIMER_FREQ        (HRT_TIMER_CLOCK / HRT_TIMER_DIVISOR)
+
+/**
+* Minimum/maximum deadlines.
+*
+* The high-resolution timer need only guarantee that it not wrap more than
+* once in the 50ms period for absolute time to be consistently maintained.
+*/
 #define HRT_INTERVAL_MIN	50
 #define HRT_INTERVAL_MAX	50000
 
-/* Actual timer frequency - MCK/32 prescaler (TC_CMR_TCCLKS_MCK32) */
-#define HRT_ACTUAL_FREQ		(HRT_TIMER_CLOCK / 32)
+/*
+* Period of the free-running counter, in timer ticks.
+*/
+#define HRT_COUNTER_PERIOD	UINT32_MAX
+#define HRT_COUNTER_PERIOD_TICKS (UINT64_C(1) << 32)
 
-/* Timer register addresses for TC0 Channel 0 */
-#define rCCR	(HRT_TIMER_BASE + SAM_TC_CCR_OFFSET)
-#define rCMR	(HRT_TIMER_BASE + SAM_TC_CMR_OFFSET)
-#define rCV	(HRT_TIMER_BASE + SAM_TC_CV_OFFSET)
-#define rRA	(HRT_TIMER_BASE + SAM_TC_RA_OFFSET)
-#define rRC	(HRT_TIMER_BASE + SAM_TC_RC_OFFSET)
-#define rSR	(HRT_TIMER_BASE + SAM_TC_SR_OFFSET)
-#define rIER	(HRT_TIMER_BASE + SAM_TC_IER_OFFSET)
-#define rIDR	(HRT_TIMER_BASE + SAM_TC_IDR_OFFSET)
-#define rIMR	(HRT_TIMER_BASE + SAM_TC_IMR_OFFSET)
+/*
+ * Scaling helpers between timer ticks and microseconds.
+ */
+static inline uint64_t hrt_ticks_to_usec(uint64_t ticks)
+{
+	return (ticks * 1000000ULL) / HRT_TIMER_FREQ;
+}
 
-/* TC Channel Control Register bits */
-#define TC_CCR_CLKEN		(1 << 0)
-#define TC_CCR_CLKDIS		(1 << 1)
-#define TC_CCR_SWTRG		(1 << 2)
+static inline uint64_t hrt_usec_to_ticks(hrt_abstime usec)
+{
+	return (usec * HRT_TIMER_FREQ + 999999ULL) / 1000000ULL;
+}
+
+#define rCCR   (HRT_TIMER_BASE + SAM_TC_CCR_OFFSET)
+#define rCMR   (HRT_TIMER_BASE + SAM_TC_CMR_OFFSET)
+#define rCV    (HRT_TIMER_BASE + SAM_TC_CV_OFFSET)
+#define rRA    (HRT_TIMER_BASE + SAM_TC_RA_OFFSET)
+#define rRB    (HRT_TIMER_BASE + SAM_TC_RB_OFFSET)
+#define rRC    (HRT_TIMER_BASE + SAM_TC_RC_OFFSET)
+#define rSR    (HRT_TIMER_BASE + SAM_TC_SR_OFFSET)
+#define rIER   (HRT_TIMER_BASE + SAM_TC_IER_OFFSET)
+#define rIDR   (HRT_TIMER_BASE + SAM_TC_IDR_OFFSET)
+#define rIMR   (HRT_TIMER_BASE + SAM_TC_IMR_OFFSET)
+
+/*
+ * Queue of callout entries.
+ */
+static struct sq_queue_s  callout_queue;
 
-/* TC register definitions - use NuttX hardware definitions */
-/* NuttX provides these in hardware/sam_tc.h */
+/* latency baseline (last compare value applied) */
+static uint32_t           latency_baseline;
 
-/* Forward declarations */
-static int hrt_tim_isr(int irq, void *context, void *arg);
+/* timer count at interrupt (for latency purposes) */
+static uint32_t           latency_actual;
 
-/* Callout list */
-static struct sq_queue_s callout_queue;
+/* latency histogram */
+const uint16_t latency_bucket_count = LATENCY_BUCKET_COUNT;
+const uint16_t latency_buckets[LATENCY_BUCKET_COUNT] = { 1, 2, 5, 10, 20, 50, 100, 1000 };
+__EXPORT uint32_t latency_counters[LATENCY_BUCKET_COUNT + 1];
 
-/* Latency histogram */
-#define LATENCY_BUCKET_COUNT 8
-__EXPORT const uint16_t latency_buckets[LATENCY_BUCKET_COUNT] = { 1, 2, 5, 10, 20, 50, 100, 1000 };
-__EXPORT uint32_t latency_actual_min = UINT32_MAX;
-__EXPORT uint32_t latency_actual_max = 0;
+static volatile uint64_t hrt_absolute_time_base;
+static volatile uint32_t hrt_last_counter_value;
+static volatile uint32_t hrt_counter_wrap_count;
 
-/* HRT clock counter */
-static uint64_t hrt_absolute_time_base;
-static uint32_t hrt_counter_wrap_count;
+static volatile bool hrt_selftest_expected;
+static volatile bool hrt_selftest_done;
 
-/**
- * Get absolute time
- */
-hrt_abstime hrt_absolute_time(void)
+static const hrt_abstime kHrtSelftestDelayUs = 200;
+static const hrt_abstime kHrtSelftestTimeoutUs = 2000;
+
+/* timer-specific functions */
+static void hrt_tim_init(void);
+static int  hrt_tim_isr(int irq, void *context, void *args);
+static void hrt_latency_update(void);
+static uint64_t hrt_ticks_locked(uint32_t *count);
+static hrt_abstime hrt_absolute_time_locked(void);
+static bool hrt_run_selftest(void);
+
+/* callout list manipulation */
+static void hrt_call_internal(struct hrt_call *entry, hrt_abstime deadline, hrt_abstime interval, hrt_callout callout,
+			      void *arg);
+static void hrt_call_enter(struct hrt_call *entry);
+static void hrt_call_reschedule(void);
+static void hrt_call_invoke(void);
+
+static uint64_t hrt_ticks_locked(uint32_t *count_out)
+{
+	uint32_t count = getreg32(rCV);
+
+	if (count < hrt_last_counter_value) {
+		hrt_absolute_time_base += HRT_COUNTER_PERIOD_TICKS;
+		hrt_counter_wrap_count++;
+	}
+
+	hrt_last_counter_value = count;
+
+	if (count_out != NULL) {
+		*count_out = count;
+	}
+
+	return hrt_absolute_time_base + count;
+}
+
+static hrt_abstime hrt_absolute_time_locked(void)
+{
+	return hrt_ticks_to_usec(hrt_ticks_locked(NULL));
+}
+
+static bool hrt_run_selftest(void)
 {
-	uint64_t base;
-	uint32_t count;
-	irqstate_t flags;
+	const uint32_t selftest_ticks = (uint32_t)hrt_usec_to_ticks(kHrtSelftestDelayUs);
+	hrt_abstime waited = 0;
+
+	irqstate_t flags = px4_enter_critical_section();
 
-	flags = enter_critical_section();
+	hrt_selftest_expected = true;
+	hrt_selftest_done = false;
 
-	/* Atomic read of base and counter */
-	base = hrt_absolute_time_base;
-	count = getreg32(rCV);
+	uint32_t current = getreg32(rCV);
+	uint32_t ra = current + selftest_ticks;
+	latency_baseline = ra;
 
-	leave_critical_section(flags);
+	putreg32(ra, rRA);
+	putreg32(TC_INT_CPAS, rIER);
 
-	/* Convert ticks to microseconds */
-	uint64_t total_ticks = base + count;
-	return (total_ticks * 1000000ULL) / HRT_ACTUAL_FREQ;
+	px4_leave_critical_section(flags);
+
+	while (!hrt_selftest_done && waited < kHrtSelftestTimeoutUs) {
+		up_udelay(50);
+		waited += 50;
+	}
+
+	flags = px4_enter_critical_section();
+
+	if (sq_peek(&callout_queue) == NULL) {
+		putreg32(TC_INT_CPAS, rIDR);
+	}
+
+	hrt_selftest_expected = false;
+	px4_leave_critical_section(flags);
+
+	return hrt_selftest_done;
 }
 
+
 /**
- * Initialize the HRT
+ * Initialize the timer we are going to use.
  */
-void hrt_init(void)
+static void hrt_tim_init(void)
 {
-	syslog(LOG_ERR, "[hrt] hrt_init starting\n");
-	sq_init(&callout_queue);
-
-	/* Enable peripheral clock for TC0 */
+	/* Enable the TC peripheral clock */
 	uint32_t regval = getreg32(SAM_PMC_PCER0);
-	syslog(LOG_ERR, "[hrt] SAM_PMC_PCER0 before: 0x%08lx\n", (unsigned long)regval);
 	regval |= HRT_TIMER_PCER;
 	putreg32(regval, SAM_PMC_PCER0);
-	syslog(LOG_ERR, "[hrt] SAM_PMC_PCER0 after: 0x%08lx\n", (unsigned long)getreg32(SAM_PMC_PCER0));
 
-	/* Disable TC clock */
+	/* Disable TC while we configure it */
 	putreg32(TC_CCR_CLKDIS, rCCR);
 
-	/* Configure TC channel mode:
-	 * - Waveform mode
-	 * - Up mode with automatic reset on RC compare
-	 * - Use MCK/8 prescaler (for ~150MHz MCK gives ~19MHz)
-	 */
-	uint32_t cmr = TC_CMR_WAVE | TC_CMR_WAVSEL_UP;
-
-	/* Select prescaler to get as close to 1MHz as possible */
-	if (HRT_TIMER_CLOCK / 8 > 1000000) {
-		cmr |= TC_CMR_TCCLKS_MCK32;  /* MCK/32 */
-		syslog(LOG_ERR, "[hrt] Using MCK/32 prescaler\n");
-	} else {
-		cmr |= TC_CMR_TCCLKS_MCK8;   /* MCK/8 */
-		syslog(LOG_ERR, "[hrt] Using MCK/8 prescaler\n");
-	}
-
+	/* Waveform mode, reset on RC compare, clocked from MCK/32 */
+	uint32_t cmr = TC_CMR_WAVE | TC_CMR_WAVSEL_UP | TC_CMR_TCCLKS_MCK32;
 	putreg32(cmr, rCMR);
 
-	/* Set RC to maximum value for free-running mode */
+	/* Set initial compare registers */
 	putreg32(0xFFFFFFFF, rRC);
+	putreg32(0xFFFFFFFF, rRA);
 
-	/* Disable all interrupts */
+	/* Disable/clear interrupts */
 	putreg32(0xFFFFFFFF, rIDR);
-
-	/* Clear status */
 	(void)getreg32(rSR);
 
-	/* Enable TC clock and trigger */
-	putreg32(TC_CCR_CLKEN | TC_CCR_SWTRG, rCCR);
-
-	/* Initialize absolute time base */
-	hrt_absolute_time_base = 0;
-	hrt_counter_wrap_count = 0;
-
-	/* Attach interrupt handler */
+	/* Attach interrupt handler and enable overflow interrupt */
 	irq_attach(HRT_TIMER_VECTOR, hrt_tim_isr, NULL);
-
-	/* Enable overflow interrupt (RC compare for wraparound) */
 	putreg32(TC_INT_CPCS, rIER);
 
-	/* Enable interrupt at NVIC level */
+	/* Start timer */
+	putreg32(TC_CCR_CLKEN | TC_CCR_SWTRG, rCCR);
+
+	/* Enable interrupts at the NVIC */
 	up_enable_irq(HRT_TIMER_VECTOR);
 
-	syslog(LOG_ERR, "[hrt] HRT initialized with interrupts, testing...\n");
+	hrt_last_counter_value = getreg32(rCV);
+	hrt_selftest_expected = false;
+	hrt_selftest_done = false;
 
-	/* Test that timer is running */
-	uint32_t cv1 = getreg32(rCV);
-	for (volatile int i = 0; i < 100000; i++);
-	uint32_t cv2 = getreg32(rCV);
-	syslog(LOG_ERR, "[hrt] Counter test: CV1=0x%08lx CV2=0x%08lx diff=%lu\n",
-		(unsigned long)cv1, (unsigned long)cv2, (unsigned long)(cv2 - cv1));
+	if (!hrt_run_selftest()) {
+		syslog(LOG_ERR, "[hrt] TC0 self-test failed (no CPAS interrupt)\n");
 
-	hrtinfo("HRT initialized\n");
+	} else {
+		syslog(LOG_INFO, "[hrt] TC0 self-test passed\n");
+	}
 }
 
 /**
- * Call callout entries
+ * Handle the compare interrupt by calling the callout dispatcher
+ * and then re-scheduling the next deadline.
  */
-static void hrt_call_invoke(void)
+static int
+hrt_tim_isr(int irq, void *context, void *arg)
 {
-	struct hrt_call *call;
-	hrt_abstime deadline __attribute__((unused));
+	uint32_t status = getreg32(rSR);
+	bool need_reschedule = false;
 
-	/* Read time once at start to avoid critical section issues */
-	uint32_t now_cv = getreg32(rCV);
-	uint64_t base = hrt_absolute_time_base;
-	uint64_t now_ticks = base + now_cv;
-	hrt_abstime now = (now_ticks * 1000000ULL) / HRT_ACTUAL_FREQ;
+	if (status & TC_INT_CPCS) {
+		need_reschedule = true;
+	}
 
-	int max_iterations = 16;  /* Prevent infinite loops */
+	if (status & TC_INT_CPAS) {
+		latency_actual = getreg32(rCV);
+		putreg32(TC_INT_CPAS, rIDR);
 
-	while (max_iterations-- > 0) {
-		call = (struct hrt_call *)sq_peek(&callout_queue);
-
-		if (call == NULL) {
-			break;
+		if (hrt_selftest_expected) {
+			hrt_selftest_done = true;
 		}
 
-		if (call->deadline > now) {
-			break;
-		}
-
-		sq_rem(&call->link, &callout_queue);
-		call->deadline = 0;
+		hrt_latency_update();
+		hrt_call_invoke();
+		need_reschedule = true;
+	}
 
-		/* Invoke callback */
-		if (call->callout) {
-			call->callout(call->arg);
-		}
+	if (need_reschedule) {
+		hrt_call_reschedule();
 	}
+
+	return OK;
 }
 
 /**
- * Reschedule next alarm
- * NOTE: Called from within critical section, so don't call hrt_absolute_time()
+ * Fetch a never-wrapping absolute time value in microseconds from
+ * some arbitrary epoch shortly after system start.
  */
-static void hrt_call_reschedule(void)
+hrt_abstime
+hrt_absolute_time(void)
 {
-	/* Read counter directly - already in critical section from caller */
-	uint32_t now_cv = getreg32(rCV);
-	uint64_t base = hrt_absolute_time_base;
-	uint64_t now_ticks = base + now_cv;
-	hrt_abstime now_usec = (now_ticks * 1000000ULL) / HRT_ACTUAL_FREQ;
+	irqstate_t flags = px4_enter_critical_section();
+	hrt_abstime abstime = hrt_absolute_time_locked();
+	px4_leave_critical_section(flags);
 
-	struct hrt_call *next = (struct hrt_call *)sq_peek(&callout_queue);
+	return abstime;
+}
 
-	if (next != NULL) {
-		hrt_abstime deadline = next->deadline;
+/**
+ * Store the absolute time in an interrupt-safe fashion
+ */
+void
+hrt_store_absolute_time(volatile hrt_abstime *t)
+{
+	irqstate_t flags = px4_enter_critical_section();
+	*t = hrt_absolute_time();
+	px4_leave_critical_section(flags);
+}
 
-		if (deadline < now_usec) {
-			deadline = now_usec + HRT_INTERVAL_MIN;
-		}
-	}
+/**
+ * Initialize the high-resolution timing module.
+ */
+void
+hrt_init(void)
+{
+	sq_init(&callout_queue);
+	memset(latency_counters, 0, sizeof(latency_counters));
+	latency_actual = 0;
+	latency_baseline = 0;
+	hrt_absolute_time_base = 0;
+	hrt_last_counter_value = 0;
+	hrt_counter_wrap_count = 0;
+	hrt_selftest_expected = false;
+	hrt_selftest_done = false;
+	hrt_tim_init();
 }
 
 /**
- * HRT interrupt handler
+ * Call callout(arg) after interval has elapsed.
  */
-static int hrt_tim_isr(int irq, void *context, void *arg)
+void
+hrt_call_after(struct hrt_call *entry, hrt_abstime delay, hrt_callout callout, void *arg)
 {
-	uint32_t status;
+	hrt_call_internal(entry,
+			  hrt_absolute_time() + delay,
+			  0,
+			  callout,
+			  arg);
+}
 
-	/* Read and clear status */
-	status = getreg32(rSR);
+/**
+ * Call callout(arg) at calltime.
+ */
+void
+hrt_call_at(struct hrt_call *entry, hrt_abstime calltime, hrt_callout callout, void *arg)
+{
+	hrt_call_internal(entry, calltime, 0, callout, arg);
+}
 
-	/* Handle counter overflow/wrap */
-	if (status & TC_INT_CPCS) {
-		hrt_counter_wrap_count++;
+/**
+ * Call callout(arg) every period.
+ */
+void
+hrt_call_every(struct hrt_call *entry, hrt_abstime delay, hrt_abstime interval, hrt_callout callout, void *arg)
+{
+	hrt_call_internal(entry,
+			  hrt_absolute_time() + delay,
+			  interval,
+			  callout,
+			  arg);
+}
+
+static void
+hrt_call_internal(struct hrt_call *entry, hrt_abstime deadline, hrt_abstime interval, hrt_callout callout, void *arg)
+{
+	irqstate_t flags = px4_enter_critical_section();
+
+	/* if the entry is currently queued, remove it */
+	/* note that we are using a potentially uninitialized
+	   entry->link here, but it is safe as sq_rem() doesn't
+	   dereference the passed node unless it is found in the
+	   list. So we potentially waste a bit of time searching the
+	   queue for the uninitialized entry->link but we don't do
+	   anything actually unsafe.
+	*/
+	if (entry->deadline != 0) {
+		sq_rem(&entry->link, &callout_queue);
 	}
 
-	/* Process callouts */
-	hrt_call_invoke();
+	entry->deadline = deadline;
+	entry->period = interval;
+	entry->callout = callout;
+	entry->arg = arg;
 
-	/* Reschedule next interrupt */
-	hrt_call_reschedule();
+	hrt_call_enter(entry);
 
-	return OK;
+	px4_leave_critical_section(flags);
 }
 
 /**
- * Call callout function at specified time
+ * If this returns true, the call has been invoked and removed from the callout list.
+ *
+ * Always returns false for repeating callouts.
  */
-void hrt_call_at(struct hrt_call *entry, hrt_abstime calltime, hrt_callout callout, void *arg)
+bool
+hrt_called(struct hrt_call *entry)
 {
-	if (entry == NULL || callout == NULL) {
-		return;
-	}
+	return (entry->deadline == 0);
+}
 
-	irqstate_t flags = enter_critical_section();
+/**
+ * Remove the entry from the callout list.
+ */
+void
+hrt_cancel(struct hrt_call *entry)
+{
+	irqstate_t flags = px4_enter_critical_section();
 
-	/* Remove from queue if already scheduled */
 	sq_rem(&entry->link, &callout_queue);
+	entry->deadline = 0;
 
-	entry->deadline = calltime;
-	entry->callout = callout;
-	entry->arg = arg;
+	/* if this is a periodic call being removed by the callout, prevent it from
+	 * being re-entered when the callout returns.
+	 */
+	entry->period = 0;
 
-	/* Insert into queue in deadline order */
-	struct hrt_call *call;
-	struct hrt_call *prev = NULL;
+	px4_leave_critical_section(flags);
+}
 
-	for (call = (struct hrt_call *)sq_peek(&callout_queue); call != NULL;
-	     call = (struct hrt_call *)sq_next(&call->link)) {
-		if (call->deadline > calltime) {
-			break;
-		}
+static void
+hrt_call_enter(struct hrt_call *entry)
+{
+	struct hrt_call	*call, *next;
 
-		prev = call;
-	}
+	call = (struct hrt_call *)sq_peek(&callout_queue);
 
-	if (prev == NULL) {
+	if ((call == NULL) || (entry->deadline < call->deadline)) {
 		sq_addfirst(&entry->link, &callout_queue);
+		hrtinfo("call enter at head, reschedule\n");
+		/* we changed the next deadline, reschedule the timer event */
+		hrt_call_reschedule();
 
 	} else {
-		sq_addafter(&prev->link, &entry->link, &callout_queue);
+		do {
+			next = (struct hrt_call *)sq_next(&call->link);
+
+			if ((next == NULL) || (entry->deadline < next->deadline)) {
+				hrtinfo("call enter after head\n");
+				sq_addafter(&call->link, &entry->link, &callout_queue);
+				break;
+			}
+		} while ((call = next) != NULL);
 	}
 
-	hrt_call_reschedule();
-
-	leave_critical_section(flags);
+	hrtinfo("scheduled\n");
 }
 
-/**
- * Call callout function after delay
- */
-void hrt_call_after(struct hrt_call *entry, hrt_abstime delay, hrt_callout callout, void *arg)
+static void
+hrt_call_invoke(void)
 {
-	hrt_call_at(entry, hrt_absolute_time() + delay, callout, arg);
+	struct hrt_call	*call;
+	hrt_abstime deadline;
+
+	while (true) {
+		/* get the current time */
+		hrt_abstime now = hrt_absolute_time();
+
+		call = (struct hrt_call *)sq_peek(&callout_queue);
+
+		if (call == NULL) {
+			break;
+		}
+
+		if (call->deadline > now) {
+			break;
+		}
+
+		sq_rem(&call->link, &callout_queue);
+		hrtinfo("call pop\n");
+
+		/* save the intended deadline for periodic calls */
+		deadline = call->deadline;
+
+		/* zero the deadline, as the call has occurred */
+		call->deadline = 0;
+
+		/* invoke the callout (if there is one) */
+		if (call->callout) {
+			hrtinfo("call %p: %p(%p)\n", call, call->callout, call->arg);
+			call->callout(call->arg);
+		}
+
+		/* if the callout has a non-zero period, it has to be re-entered */
+		if (call->period != 0) {
+			// re-check call->deadline to allow for
+			// callouts to re-schedule themselves
+			// using hrt_call_delay()
+			if (call->deadline <= now) {
+				call->deadline = deadline + call->period;
+			}
+
+			hrt_call_enter(call);
+		}
+	}
 }
 
 /**
- * Call callout function at periodic intervals
+ * Reschedule the next timer interrupt.
+ *
+ * This routine must be called with interrupts disabled.
  */
-void hrt_call_every(struct hrt_call *entry, hrt_abstime delay, hrt_abstime interval, hrt_callout callout, void *arg)
+static void
+hrt_call_reschedule()
 {
-	entry->period = interval;
-	hrt_call_after(entry, delay, callout, arg);
+	irqstate_t flags = px4_enter_critical_section();
+
+	struct hrt_call *next = (struct hrt_call *)sq_peek(&callout_queue);
+
+	if (next == NULL) {
+		putreg32(TC_INT_CPAS, rIDR);
+		px4_leave_critical_section(flags);
+		return;
+	}
+
+	uint32_t current_count;
+	uint64_t now_ticks = hrt_ticks_locked(&current_count);
+	hrt_abstime now = hrt_ticks_to_usec(now_ticks);
+	hrt_abstime deadline = now + HRT_INTERVAL_MAX;
+
+	if (next->deadline <= (now + HRT_INTERVAL_MIN)) {
+		deadline = now + HRT_INTERVAL_MIN;
+
+	} else if (next->deadline < deadline) {
+		deadline = next->deadline;
+	}
+
+	hrt_abstime delta_us = deadline - now;
+	uint64_t delta_ticks = hrt_usec_to_ticks(delta_us);
+
+	if (delta_ticks == 0) {
+		delta_ticks = 1;
+	}
+
+	uint32_t ra = current_count + (uint32_t)delta_ticks;
+	latency_baseline = ra;
+
+	putreg32(ra, rRA);
+	putreg32(TC_INT_CPAS, rIER);
+
+	px4_leave_critical_section(flags);
 }
 
-/**
- * Cancel a callout
- */
-void hrt_cancel(struct hrt_call *entry)
+static void
+hrt_latency_update(void)
 {
-	irqstate_t flags = enter_critical_section();
+	uint32_t latency = latency_actual - latency_baseline;
+	unsigned	index;
+
+	/* bounded buckets */
+	for (index = 0; index < LATENCY_BUCKET_COUNT; index++) {
+		if (latency <= latency_buckets[index]) {
+			latency_counters[index]++;
+			return;
+		}
+	}
 
-	sq_rem(&entry->link, &callout_queue);
-	entry->deadline = 0;
-	entry->period = 0;
+	/* catch-all at the end */
+	latency_counters[index]++;
+}
 
-	leave_critical_section(flags);
+void
+hrt_call_init(struct hrt_call *entry)
+{
+	memset(entry, 0, sizeof(*entry));
 }
 
-/* CPU load monitoring support function */
-void hrt_store_absolute_time(volatile hrt_abstime *t)
+void
+hrt_call_delay(struct hrt_call *entry, hrt_abstime delay)
 {
-	*t = hrt_absolute_time();
+	entry->deadline = hrt_absolute_time() + delay;
 }
 
 #endif /* HRT_TIMER */
diff --git a/platforms/nuttx/src/px4/microchip/samv7/io_pins/io_timer_stub.c b/platforms/nuttx/src/px4/microchip/samv7/io_pins/io_timer_stub.c
index b83a69d94b..d5c593ffad 100644
--- a/platforms/nuttx/src/px4/microchip/samv7/io_pins/io_timer_stub.c
+++ b/platforms/nuttx/src/px4/microchip/samv7/io_pins/io_timer_stub.c
@@ -56,6 +56,3 @@ uint32_t io_timer_channel_get_as_pwm_input(unsigned channel)
 	(void)channel;
 	return 0;
 }
-
-/* Performance monitoring latency counters */
-uint32_t latency_counters[8];  /* Global latency counter array */
